from glusto.core import Glusto as g
# from flex.lib.connect.connect_to_sheets import SheetsConnector
# from flex.lib.data_clean.fix_df import FixUpDf
# from flex.lib.data_clean.remove import Remove
# from flex.lib.generate_lineup.closest_to_num import ClosestToNum
from flex.lib.generate_lineup.assemble_lineup import Assemble
import pytest
import random
import numpy as np
import pandas as pd
import os
# import time


class TestBuildLineup:

    g.add_log(g.log, filename='./logs/BuildLineupLog')

    @pytest.mark.build_lineup
    def test_closest_to_num(self, rawDataframe, print_logging, full_dataframe_prep):
        """
        This test will make sure that the closest value to the STD of 1 is being returned.
        :param rawDataframe:
        :param print_logging:
        :param full_dataframe_prep:
        :return:
        """

        g.log.info('Instantiate the positional dataframes')
        QB, RB, WR, TE, FLX, DST = full_dataframe_prep

        # Set the STD values for each position
        # TODO: Work on making this user input or autogenerated.
        QB_STD = random.randint(1, 6)
        RB_STD = random.randint(1, 6)
        RB2_STD = random.randint(1, 6)
        WR_STD = random.randint(1, 6)
        WR2_STD = random.randint(1, 6)
        WR3_STD = random.randint(1, 6)
        TE_STD = random.randint(1, 6)
        FLX_STD = random.randint(1, 6)
        DST_STD = random.randint(1, 6)

        g.log.info(QB_STD)
        g.log.info(RB_STD)
        g.log.info(RB2_STD)
        g.log.info(WR_STD)
        g.log.info(WR2_STD)
        g.log.info(WR3_STD)
        g.log.info(TE_STD)
        g.log.info(FLX_STD)
        g.log.info(DST_STD)

        # Instantiate assemble object
        assemble = Assemble()

        # Run createLineup function to create lineup based on closest to STD From the list given
        lineup = assemble.createLineup(QB, RB, WR, TE, FLX, DST, QB_STD, RB_STD, RB2_STD, WR_STD, WR2_STD, WR3_STD, TE_STD, FLX_STD, DST_STD)

        g.log.info(lineup)

        if assemble.hasValidSalary(lineup):
            g.log.info('Total Points: %s Total Salary: %s' % (lineup[9], lineup[10]))
            assert True
        else:
            g.log.info('Salary is not right')
            assert False

    @pytest.mark.build_historic
    def test_historic(self, rawDataframe, print_logging, full_dataframe_prep):
        """
        This test will make sure that the closest value to the STD of 1 is being returned.
        :param rawDataframe:
        :param print_logging:
        :param full_dataframe_prep:
        :return:
        """

        g.log.info('Instantiate the positional dataframes')
        QB, RB, WR, TE, FLX, DST = full_dataframe_prep

        # Set the STD values for each position
        # TODO: Work on making this user input or autogenerated.
        # std = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]

        winner = 0
        # for i in np.arange(0, 10, 0.01):
        for i in np.arange(0, 5):

            QB_STD = i
            RB_STD = i
            RB2_STD = i
            WR_STD = i
            WR2_STD = i
            WR3_STD = i
            TE_STD = i
            FLX_STD = i
            DST_STD = i

            g.log.info(QB_STD)
            g.log.info(RB_STD)
            g.log.info(RB2_STD)
            g.log.info(WR_STD)
            g.log.info(WR2_STD)
            g.log.info(WR3_STD)
            g.log.info(TE_STD)
            g.log.info(FLX_STD)
            g.log.info(DST_STD)

            # Instantiate assemble object
            assemble = Assemble()

            # Run createLineup function to create lineup based on closest to STD From the list given
            lineup = assemble.createLineup(QB, RB, WR, TE, FLX, DST, QB_STD, RB_STD, RB2_STD, WR_STD, WR2_STD, WR3_STD, TE_STD, FLX_STD, DST_STD)

            g.log.info(lineup)

            if assemble.hasValidSalary(lineup):
                g.log.info('Total Points: %s Total Salary: %s' % (lineup[9], lineup[10]))
                if winner == 0:
                    winner = lineup[9]
                elif lineup[9] > winner:
                    winner = lineup[9]
                    g.log.info('Winning Lineup Currently is %s' % winner)
                else:
                    g.log.info('Winning Lineup Currently is %s' % winner)
                    assert True
            else:
                g.log.info('Lineup failed salary check!!')

    @pytest.mark.fd_entry
    def test_FanDuel_Entry(self, rawDataframe, print_logging, full_dataframe_prep, deftestdata):
        """
        This test will make sure that the closest value to the STD of 1 is being returned.
        :param rawDataframe:
        :param print_logging:
        :param full_dataframe_prep:
        :return:
        """

        g.log.info('Instantiate the positional dataframes')
        QB, RB, WR, TE, FLX, DST = full_dataframe_prep

        # Set the STD values for each position
        # TODO: Work on making this user input or autogenerated.
        # std = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]

        QB_STD = deftestdata['QB_std']
        RB_STD = deftestdata['RB_std']
        WR_STD = deftestdata['WR_std']
        TE_STD = deftestdata['TE_std']
        DST_STD = deftestdata['DST_std']
        FLX_STD = deftestdata['FLX_std']
        QB_STD2 = deftestdata['QB_std2']
        RB_STD2 = deftestdata['RB_std2']
        WR_STD2 = deftestdata['WR_std2']
        TE_STD2 = deftestdata['TE_std2']
        DST_STD2 = deftestdata['DST_std2']
        FLX_STD2 = deftestdata['FLX_std2']
        min_sal = deftestdata['min_sal']
        master_csv = deftestdata['master_csv']
        master_csv2 = deftestdata['master_csv2']
        collect_master_csv = deftestdata['collect_master_csv']
        collect_second_csv = deftestdata['collect_second_csv']
        count = deftestdata['count']
        pairing = deftestdata['pairing']

        # target_STD = 3.5
        QB_STD = QB_STD
        RB_STD = RB_STD
        RB2_STD = RB_STD
        WR_STD = WR_STD
        WR2_STD = WR_STD
        WR3_STD = WR_STD
        TE_STD = TE_STD
        FLX_STD = FLX_STD
        DST_STD = DST_STD

        QB_STD2 = QB_STD2
        RB_STD2 = RB_STD2
        RB2_STD2 = RB_STD2
        WR_STD2 = WR_STD2
        WR2_STD2 = WR_STD2
        WR3_STD2 = WR_STD2
        TE_STD2 = TE_STD2
        FLX_STD2 = FLX_STD2
        DST_STD2 = DST_STD2

        g.log.info('STDs for first lineup')
        g.log.info(QB_STD)
        g.log.info(RB_STD)
        g.log.info(RB2_STD)
        g.log.info(WR_STD)
        g.log.info(WR2_STD)
        g.log.info(WR3_STD)
        g.log.info(TE_STD)
        g.log.info(FLX_STD)
        g.log.info(DST_STD)

        g.log.info('STDs for second lineup')
        g.log.info(QB_STD2)
        g.log.info(RB_STD2)
        g.log.info(RB2_STD2)
        g.log.info(WR_STD2)
        g.log.info(WR2_STD2)
        g.log.info(WR3_STD2)
        g.log.info(TE_STD2)
        g.log.info(FLX_STD2)
        g.log.info(DST_STD2)

        # Instantiate assemble object
        assemble = Assemble()

        # Run createLineup function to create lineup based on closest to STD From the list given
        lineup = assemble.createLineup(QB, RB, WR, TE, FLX, DST, QB_STD, RB_STD, RB2_STD, WR_STD, WR2_STD, WR3_STD, TE_STD, FLX_STD, DST_STD)

        g.log.info(lineup)

        lineup = assemble.findBestLineup(lineup, QB, RB, WR, TE, FLX, DST, QB_STD, RB_STD, RB2_STD, WR_STD, WR2_STD, WR3_STD, TE_STD, FLX_STD, DST_STD, min_sal, pairing)
        g.log.info('This is your winning lineup: \n %s' % lineup)
        if lineup:
            with open(master_csv, 'w') as f:
                master_lineup = pd.DataFrame(lineup[9:])
                print(master_lineup)
                master_lineup = master_lineup.transpose()
                if os.stat(master_csv).st_size == 0:
                    master_lineup.columns = ["Points", "Salary"]
                    master_lineup['Count'] = count
                    master_lineup.to_csv(f)
                else:
                    master_lineup['Count'] = count
                    master_lineup.to_csv(f, header=False)
            with open(collect_master_csv, 'w') as f:
                QB = QB[QB['player'] != lineup[0][0]]
                RB = RB[RB['player'] != lineup[1][0]]
                RB = RB[RB['player'] != lineup[2][0]]
                WR = WR[WR['player'] != lineup[3][0]]
                WR = WR[WR['player'] != lineup[4][0]]
                WR = WR[WR['player'] != lineup[5][0]]
                TE = TE[TE['player'] != lineup[6][0]]
                g.log.info('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
                g.log.info(lineup[7][0])
                if RB['player'].str.contains(lineup[7][0]).any():
                    RB = RB[RB['player'] != lineup[7][0]]
                    g.log.info(RB)
                if WR['player'].str.contains(lineup[7][0]).any():
                    WR = WR[WR['player'] != lineup[7][0]]
                if TE['player'].str.contains(lineup[7][0]).any():
                    TE = TE[TE['player'] != lineup[7][0]]
                FLX = FLX[FLX['player'] != lineup[7][0]]
                FLX = FLX[FLX['player'] != lineup[1][0]]
                FLX = FLX[FLX['player'] != lineup[2][0]]
                FLX = FLX[FLX['player'] != lineup[3][0]]
                FLX = FLX[FLX['player'] != lineup[4][0]]
                FLX = FLX[FLX['player'] != lineup[5][0]]
                FLX = FLX[FLX['player'] != lineup[6][0]]
                DST = DST[DST['player'] != lineup[8][0]]
                collect_lineup = pd.DataFrame(lineup[:9])
                print(collect_lineup)
                collect_lineup.to_csv(f, header=['player', 'team', 'position', 'projection', 'salary', 'stdev'], index_label='id')

            g.log.info('Generating second lineup with no duplicates!')
            # time.sleep(5)
            lineup2 = assemble.createLineup(QB, RB, WR, TE, FLX, DST, QB_STD2, RB_STD2, RB2_STD2, WR_STD2, WR2_STD2, WR3_STD2, TE_STD2, FLX_STD2, DST_STD2)
            g.log.info(lineup2)

            lineup2 = assemble.findBestLineup(lineup2, QB, RB, WR, TE, FLX, DST, QB_STD2, RB_STD2, RB2_STD2, WR_STD2, WR2_STD2, WR3_STD2, TE_STD2, FLX_STD2, DST_STD2, min_sal, pairing)  # noqa E501
            g.log.info('This is your winning lineup: \n %s' % lineup2)
            if lineup2:
                with open(master_csv2, 'w') as f:

                    master_lineup = pd.DataFrame(lineup2[9:])
                    master_lineup = master_lineup.transpose()
                    if os.stat(master_csv).st_size == 0:
                        master_lineup.columns = ["Points", "Salary"]
                        master_lineup['Count'] = count
                        master_lineup.to_csv(f)
                    else:
                        master_lineup['Count'] = count
                        master_lineup.to_csv(f, header=False)
                with open(collect_second_csv, 'w') as f:
                    collect_lineup = pd.DataFrame(lineup2[:9])
                    collect_lineup.to_csv(f, header=['player', 'team', 'position', 'projection', 'salary', 'stdev'], index_label='id')
            # assert True

    @pytest.mark.current_week
    def test_Current_Week(self, rawDataframe, print_logging, full_dataframe_prep, deftestdata):
        """
        This test will make sure that the closest value to the STD of 1 is being returned.
        :param rawDataframe:
        :param print_logging:
        :param full_dataframe_prep:
        :return:
        """

        g.log.info('Instantiate the positional dataframes')
        QB, RB, WR, TE, FLX, DST = full_dataframe_prep

        # Set the STD values for each position
        # TODO: Work on making this user input or autogenerated.
        # std = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]

        QB_STD = deftestdata['QB_std']
        RB_STD = deftestdata['RB_std']
        WR_STD = deftestdata['WR_std']
        TE_STD = deftestdata['TE_std']
        DST_STD = deftestdata['DST_std']
        FLX_STD = deftestdata['FLX_std']
        min_sal = deftestdata['min_sal']
        master_csv = deftestdata['master_csv']
        count = deftestdata['count']
        pairing = deftestdata['pairing']

        # target_STD = 3.5
        QB_STD = QB_STD
        RB_STD = RB_STD
        RB2_STD = RB_STD
        WR_STD = WR_STD
        WR2_STD = WR_STD
        WR3_STD = WR_STD
        TE_STD = TE_STD
        FLX_STD = FLX_STD
        DST_STD = DST_STD

        g.log.info(QB_STD)
        g.log.info(RB_STD)
        g.log.info(RB2_STD)
        g.log.info(WR_STD)
        g.log.info(WR2_STD)
        g.log.info(WR3_STD)
        g.log.info(TE_STD)
        g.log.info(FLX_STD)
        g.log.info(DST_STD)

        # Instantiate assemble object
        assemble = Assemble()

        # Run createLineup function to create lineup based on closest to STD From the list given
        lineup = assemble.createLineup(QB, RB, WR, TE, FLX, DST, QB_STD, RB_STD, RB2_STD, WR_STD, WR2_STD, WR3_STD, TE_STD, FLX_STD, DST_STD)

        g.log.info(lineup)

        lineup = assemble.findBestLineup(lineup, QB, RB, WR, TE, FLX, DST, QB_STD, RB_STD, RB2_STD, WR_STD, WR2_STD, WR3_STD, TE_STD, FLX_STD, DST_STD, min_sal, pairing)
        g.log.info('This is your winning lineup: \n %s' % lineup)
        if lineup:
            with open(master_csv, 'w') as f:
                lineup = pd.DataFrame(lineup[9:])
                lineup = lineup.transpose()
                if os.stat(master_csv).st_size == 0:
                    lineup.columns = ["Points", "Salary"]
                    lineup['Count'] = count
                    lineup.to_csv(f)
                else:
                    lineup['Count'] = count
                    lineup.to_csv(f, header=False)
            assert True

    @pytest.mark.lineup_analysis
    def test_Lineup_Creation_Data(self, rawDataframe, print_logging, full_dataframe_prep, deftestdata):
        """
        This test is going to be used to generate a lineup for a historical week and
        save the lineup to a csv file, appending the output if the file already exists.

        This csv data will then be used to analyze the lineups data.
        :param rawDataframe:
        :param print_logging:
        :param full_dataframe_prep: preps dataframe for lineup creation.
        :return:
        """

        g.log.info('Instantiate the positional dataframes')
        QB, RB, WR, TE, FLX, DST = full_dataframe_prep

        # Set the STD values for each position
        # TODO: Work on making this user input or autogenerated.
        # std = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]

        QB_STD = deftestdata['QB_std']
        RB_STD = deftestdata['RB_std']
        WR_STD = deftestdata['WR_std']
        TE_STD = deftestdata['TE_std']
        DST_STD = deftestdata['DST_std']
        FLX_STD = deftestdata['FLX_std']
        min_sal = deftestdata['min_sal']
        master_csv = deftestdata['master_csv']
        # Count is STD value
        count = deftestdata['count']
        pairing = deftestdata['pairing']

        # target_STD = 3.5
        QB_STD = QB_STD
        RB_STD = RB_STD
        RB2_STD = RB_STD
        WR_STD = WR_STD
        WR2_STD = WR_STD
        WR3_STD = WR_STD
        TE_STD = TE_STD
        FLX_STD = FLX_STD
        DST_STD = DST_STD

        g.log.info(QB_STD)
        g.log.info(RB_STD)
        g.log.info(RB2_STD)
        g.log.info(WR_STD)
        g.log.info(WR2_STD)
        g.log.info(WR3_STD)
        g.log.info(TE_STD)
        g.log.info(FLX_STD)
        g.log.info(DST_STD)

        # Instantiate assemble object
        assemble = Assemble()

        # Run createLineup function to create lineup based on closest to STD From the list given
        lineup = assemble.createLineup(QB, RB, WR, TE, FLX, DST, QB_STD, RB_STD, RB2_STD, WR_STD, WR2_STD, WR3_STD, TE_STD, FLX_STD, DST_STD)

        g.log.info(lineup)

        lineup = assemble.findBestLineup(lineup, QB, RB, WR, TE, FLX, DST, QB_STD, RB_STD, RB2_STD, WR_STD, WR2_STD, WR3_STD, TE_STD, FLX_STD, DST_STD, min_sal, pairing)
        g.log.info('This is your winning lineup: \n %s' % lineup)
        if lineup:
            with open(master_csv, 'w') as f:
                lineup = pd.DataFrame(lineup[9:])
                lineup = lineup.transpose()
                lineup['2'] = count
                if os.stat(master_csv).st_size == 0:
                    lineup.columns = ["Points", "Salary", "STD"]
                    lineup.to_csv(f)
                else:
                    lineup.to_csv(f, header=False)
            assert True

    @pytest.mark.track_history
    def test_track_history(self, rawDataframe, print_logging, full_dataframe_prep):
        """
        This test will make sure that the closest value to the STD of 1 is being returned.
        :param rawDataframe:
        :param print_logging:
        :param full_dataframe_prep:
        :return:
        """

        g.log.info('Instantiate the positional dataframes')
        QB, RB, WR, TE, FLX, DST = full_dataframe_prep

        # Set the STD values for each position
        # TODO: Work on making this user input or autogenerated.
        # std = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]

        # for i in np.arange(0, 2):
        for i in np.arange(0, 10, 0.5):
            QB_STD = i
            RB_STD = i
            RB2_STD = i
            WR_STD = i
            WR2_STD = i
            WR3_STD = i
            TE_STD = i
            FLX_STD = i
            DST_STD = i

            g.log.info(QB_STD)
            g.log.info(RB_STD)
            g.log.info(RB2_STD)
            g.log.info(WR_STD)
            g.log.info(WR2_STD)
            g.log.info(WR3_STD)
            g.log.info(TE_STD)
            g.log.info(FLX_STD)
            g.log.info(DST_STD)

            # Instantiate assemble object
            assemble = Assemble()

            # Run createLineup function to create lineup based on closest to STD From the list given
            lineup = assemble.createLineup(QB, RB, WR, TE, FLX, DST, QB_STD, RB_STD, RB2_STD, WR_STD, WR2_STD, WR3_STD, TE_STD, FLX_STD, DST_STD)

            g.log.info(lineup)

            lineup = assemble.collectLineupData(lineup, QB, RB, WR, TE, FLX, DST, QB_STD, RB_STD, RB2_STD, WR_STD, WR2_STD, WR3_STD, TE_STD, FLX_STD, DST_STD)

            # if assemble.hasValidSalary(lineup):
            #     g.log.info('Total Points: %s Total Salary: %s' % (lineup[9], lineup[10]))
            #     if winner == 0:
            #         winner = lineup[9]
            #     elif lineup[9] > winner:
            #         winner = lineup[9]
            #         g.log.info('Winning Lineup Currently is %s' % winner)
            #     else:
            #         g.log.info('Winning Lineup Currently is %s' % winner)
            #         assert True
            # else:
            #     g.log.info('Lineup failed salary check!!')

            g.log.info('This is you lineup: \n %s' % lineup)
            # if lineup:
            #     assert True
